<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Puzzle 7</title>
  <style>
    @keyframes typing {
      0% { width: 0 }
      100% { width: 100% }
    }

    @keyframes blinkCaret {
      0%, 100% { border-color: transparent }
      50% { border-color: #00ff88 }
    }

    body {
      background-color: #0d0d0d;
      color: #00ff88;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      padding: 20px;
    }

    .terminal {
      background-color: #000000;
      border: 2px solid #00ff88;
      padding: 20px;
      width: 90%;
      max-width: 700px;
      height: 400px;
      overflow-y: auto;
      box-shadow: 0 0 20px #00ff88;
      white-space: pre-wrap;
      font-size: 16px;
    }

    .line {
      font-family: 'Courier New', monospace;
      white-space: pre-wrap;
      margin-bottom: 4px;
      border: none;
    }

    .cursor {
      display: inline-block;
      width: 10px;
      color: #00ff88;
      animation: blink 1s steps(2, start) infinite;
      user-select: none;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }


    .line.finished {
      border-right: none;
      animation: none;
      white-space: pre-wrap;
      overflow: visible;
      width: 100% !important;
    }

    .input-line {
      display: flex;
      align-items: center;
      margin-top: 10px;
    }

    .prompt {
      margin-right: 5px;
    }

    #commandInput {
      background-color: #000;
      color: #00ff88;
      border: none;
      outline: none;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      flex: 1;
    }

    .back-button {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 10px 16px;
      font-size: 14px;
      background-color: #111;
      color: #ccc;
      border: 1px solid #444;
      cursor: pointer;
      z-index: 100;
    }
  </style>
</head>
<body>
  <button class="back-button" onclick="window.location.href='index.html'">← Back</button>
  <div class="terminal" id="terminal"></div>

  <script>
    const terminal = document.getElementById('terminal');

    // Pierwotne linie tekstu
    const introLines = [
      "SYSTEM INIT SEQUENCE 0x7A9F3B",
      "MEMORY FRAGMENTS ONLINE...",
      "LOADING SECTOR 7.3.26...",
      "[INFO] Data integrity: 87%",
      "[WARNING] Sector 4: Missing data segment.",
      "[LOG] Partial memory dump follows:",
      "  > Segment A1F: 0xD4 0xE5 0xB9 0x47 0x99",
      "  > Segment C2D: 0x55 0xFC 0x3B 0x6A 0x1D",
      "[SYSTEM] Reconstruction protocols active.",
      "",
      "TYPE 'HELP' FOR A LIST OF COMMANDS.",
      ""
    ];

    let awaitingInput = false;

    function typeLine(text, delay = 100) {
  return new Promise((resolve) => {
    const line = document.createElement('div');
    line.className = 'line';
    terminal.appendChild(line);
    terminal.scrollTop = terminal.scrollHeight;

    const cursor = document.createElement('span');
    cursor.className = 'cursor';
    cursor.textContent = '_';
    line.appendChild(cursor);

    let i = 0;
    function typeChar() {
      if (i < text.length) {
        // przed kursorem dopisujemy kolejną literę
        cursor.insertAdjacentText('beforebegin', text[i]);
        i++;
        terminal.scrollTop = terminal.scrollHeight;
        setTimeout(typeChar, delay);
      } else {
        // zakończ animację migania kursora (usuń kursor)
        cursor.remove();
        resolve();
      }
    }
    typeChar();
  });
}


    // Dodaje linię z inputem do terminala, bez animacji fade-in
    function addInputField() {
      const inputLine = document.createElement('div');
      inputLine.className = 'input-line';

      const prompt = document.createElement('span');
      prompt.className = 'prompt';
      prompt.textContent = '>';

      const input = document.createElement('input');
      input.type = 'text';
      input.id = 'commandInput';
      input.autofocus = true;
      input.spellcheck = false;
      input.autocomplete = "off";

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !awaitingInput) {
          const val = input.value.trim();
          if(val.length === 0) return; // pusty input ignorujemy
          awaitingInput = true;
          input.disabled = true;
          processCommand(val);
        }
      });

      inputLine.appendChild(prompt);
      inputLine.appendChild(input);
      terminal.appendChild(inputLine);
      terminal.scrollTop = terminal.scrollHeight;
      input.focus();
    }

    // Funkcja wyświetlająca wiele linii animowanych kolejno (asynchronicznie)
    async function printIntroLines() {
      for(let i = 0; i < introLines.length; i++){
        await typeLine(introLines[i]);
      }
      addInputField();
    }

    async function processCommand(cmdRaw) {
      const cmd = cmdRaw.toUpperCase();

      switch(cmd) {
        case "HELP":
          await typeMultiLine([
            "Available commands:",
            "HELP        - Show this help text",
            "STATUS      - Show current system status",
            "DUMP        - Dump memory fragments",
            "TRACE       - Show recent trace logs",
            "RECONSTRUCT - Attempt data reconstruction",
            "RESET       - Restart session"
          ]);
          break;

        case "STATUS":
          await typeMultiLine([
            "SYSTEM STATUS:",
            " - Memory integrity: 87%",
            " - Active protocols: RECONSTRUCT, TRACE",
            " - Intrusion attempts: 4 detected",
            " - System uptime: 3h 12m",
            " - Last reset: 207-03-26"
          ]);
          break;

        case "DUMP":
          await typeMultiLine([
            "MEMORY DUMP SEGMENTS:",
            " A1F: 0xD4 0xE5 0xB9 0x47 0x99",
            " C2D: 0x55 0xFC 0x3B 0x6A 0x1D",
            " E4A: 0x9A 0xBB 0x1E 0x44 0x77",
            " F12: 0x6F 0xA3 0xC9 0x10 0x22"
          ]);
          break;

        case "TRACE":
          await typeMultiLine([
            "TRACE LOG:",
            " Intrusion attempt from IP 192.168.7.32 blocked.",
            " Multiple failed auth from 10.4.15.26.",
            " Malware signature detected in sector 4.",
            " Trace vector rerouted through node 9."
          ]);
          break;

        case "RECONSTRUCT":
          await typeMultiLine([
            "RECONSTRUCTION INITIATED...",
            " Analyzing fragments...",
            " Data missing at segment 4.",
            " Possible keyword pattern detected.",
            " [ACCESS CODE FRAGMENTS: 207 3 26]",
            " Enter passphrase to unlock."
          ]);
          break;

        case "RESET":
          terminal.innerHTML = '';
          awaitingInput = false;
          printIntroLines();
          return;  // przerwij dalej

        default:
          // Tu podstawowa zagadka - hasło
          if(cmd === "UNLOCK" || cmd === "ACCESS" || cmd === "OPEN") {
            await typeLine("ACCESS DENIED: Passphrase required.");
          } else if (cmdRaw.toLowerCase() === 'didyufrget') {
            localStorage.setItem("puzzle7", "solved");
            await typeLine("ACCESS GRANTED – Code: 207 3 26", 0);
          } else {
            await typeLine("ERROR: Unknown command. Type HELP for options.");
          }
          break;
      }

      awaitingInput = false;
      addInputField();
    }

    // Pomocnicza funkcja do wyświetlania wielu linii po kolei (animacja)
    async function typeMultiLine(lines) {
      for (let i=0; i<lines.length; i++) {
        await typeLine(lines[i]);
      }
    }

    window.onload = () => {
      printIntroLines();
    };
  </script>
</body>
</html>
